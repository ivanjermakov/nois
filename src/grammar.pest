program                       = _{ SOI ~ block ~ EOI }
  block                       =  { N* ~ (statement ~ N+)* ~ statement? }
    statement                 = _{ return_statement | assignment | expression }
      return_statement        =  { RETURN_KEYWORD ~ expression? }
      assignment              =  { assignee ~ EQUALS ~ expression }
      expression              =  { sub_expression ~ (N* ~ binary_operator ~ N* ~ sub_expression)* }
        sub_expression        = _{ unary_expression | operand | braced_expression }
        unary_expression      =  { unary_operator ~ braced_expression }
        braced_expression     = _{ (operand | (PAREN_OPEN ~ N* ~ expression ~ N* ~ PAREN_CLOSE)) }
        binary_operator       =  {
          ADD_OP | SUBTRACT_OP | MULTIPLY_OP | DIVIDE_OP | EXPONENT_OP | REMAINDER_OP
          | ACCESSOR_OP | EQUALS_OP | NOT_EQUALS_OP | GREATER_OP | GREATER_OR_EQUALS_OP | LESS_OP | LESS_OR_EQUALS_OP | AND_OP | OR_OP
        }
        unary_operator        =  { ADD_OP | SUBTRACT_OP | NOT_OP | SPREAD_OP }

operand                       = _{
    HOLE_OP
  | float
  | integer
  | boolean
  | match_expression
  | struct_define
  | enum_define
  | function_init
  | list_init
  | function_call
  | string
  | identifier
}
  /// #EF9F76
  integer                     = @{
    ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
  }
  float                       = @{
    integer ~ ("." ~ ASCII_DIGIT+) | integer ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)
  }
  boolean                       = @{ "True" | "False" }
  struct_define               =  {
    STRUCT_OP ~ BRACE_OPEN ~ N*
      ~ identifier? ~ N*
      ~ (COMMA ~ N* ~ identifier ~ N*)* ~ COMMA?
    ~ BRACE_CLOSE }
  enum_define                 =  {
    ENUM_OP ~ BRACE_OPEN ~ N*
      ~ identifier? ~ N*
      ~ (COMMA ~ N* ~ identifier ~ N*)* ~ COMMA?
    ~ BRACE_CLOSE }
  /// #DDFF88
  list_init                   =  {
    BRACKET_OPEN ~ N*
      ~ (N* ~ expression ~ (N* ~ COMMA ~ N* ~ expression ~ N*)*)?
      ~ COMMA? ~ N*
    ~ BRACKET_CLOSE }
  function_init               =  { block_function_init | arrow_function_init }
    block_function_init       = _{ argument_list ~ BRACE_OPEN ~ block ~ BRACE_CLOSE }
    arrow_function_init       = _{ argument_list ~ ARROW_OP ~ N* ~ statement }
      argument_list      	  =  { _argument_list? }
      // required to always include argument_list in parse tree, even if it's not specified
      _argument_list          = _{
        assignee ~ N*
        | (PAREN_OPEN ~ N*
          ~ assignee? ~ N* ~ (COMMA ~ N* ~ assignee ~ N*)* ~ COMMA? ~ N*
        ~ PAREN_CLOSE)
      }
  function_call               =  { identifier ~ PAREN_OPEN ~ N* ~ parameter_list ~ N* ~ PAREN_CLOSE }
    parameter_list            =  { expression? ~ N* ~ (COMMA ~ N* ~ expression)* ~ COMMA? }

assignee                      =  { pattern | identifier }
  pattern                     =  { HOLE_OP | list_pattern }
  list_pattern                = _{
    BRACKET_OPEN ~ N*
    ~ (N* ~ pattern_item? ~ (N* ~ COMMA ~ N* ~ pattern_item ~ N*)*)?
    ~ COMMA? ~ N*
    ~ BRACKET_CLOSE
  }
    pattern_item              =  { HOLE_OP | SPREAD_OP? ~ identifier }

match_expression              =  {
  MATCH_KEYWORD ~ expression ~ BRACE_OPEN ~ N*
    ~ match_clause ~ N* ~ (COMMA ~ N* ~ match_clause)* ~ COMMA? ~ N*
  ~ BRACE_CLOSE
}
  match_clause                =  { predicate_expression ~ MATCH_OP ~ block }
    predicate_expression      =  { pattern | expression }

/// #AA66CC
identifier                    = @{ ASCII_ALPHANUMERIC+ }
/// #A6D189
string                        = @{string_single | string_double}
string_single                 = _{ QUOTE ~ inner_string ~ QUOTE }
string_double                 = _{ DOUBLE_QUOTE ~ inner_string ~ DOUBLE_QUOTE }
inner_string                  = @{ char* }
char                          = _{
  !("\"" | "\\" | "'" | "'") ~ ANY
  | "\\" ~ ("\"" | "\\" | "/" | "n" | "r" | "t")
  | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
RETURN_KEYWORD                = _{ "return" }
MATCH_KEYWORD                 = _{ "match" }
MATCH_OP                      = _{ "=>" }
STRUCT_OP                     = _{ "#" }
ENUM_OP                       = _{ "|" }
ARROW_OP                      = _{ "->" }
EQUALS_OP                     =  { "==" }
NOT_EQUALS_OP                 =  { "!=" }
AND_OP                        =  { "&&" }
OR_OP                         =  { "||" }
NOT_OP                        =  { !NOT_EQUALS_OP ~ "!" }
SUBTRACT_OP                   =  { !ARROW_OP ~ "-" }
ADD_OP                        =  { "+" }
MULTIPLY_OP                   =  { "*" }
DIVIDE_OP                     =  { "/" }
EXPONENT_OP                   =  { "^" }
GREATER_OP                    =  { !GREATER_OR_EQUALS_OP ~ ">" }
GREATER_OR_EQUALS_OP          =  { ">=" }
LESS_OP                       =  { !LESS_OR_EQUALS_OP ~ "<" }
LESS_OR_EQUALS_OP             =  { "<=" }
REMAINDER_OP                  =  { "%" }
ACCESSOR_OP                   =  { !SPREAD_OP ~ "." }
SPREAD_OP                     =  { ".." }
HOLE_OP                       =  { "_" }
EQUALS                        = _{ !EQUALS_OP ~ "=" }
BRACE_OPEN                    = _{ "{" }
BRACE_CLOSE                   = _{ "}" }
PAREN_OPEN                    = _{ "(" }
PAREN_CLOSE                   = _{ ")" }
BRACKET_OPEN                  = _{ "[" }
BRACKET_CLOSE                 = _{ "]" }
QUOTE                         = _{ "'" }
DOUBLE_QUOTE                  = _{ "\"" }
COMMA                         = _{ "," }
AMPERSAND                     = _{ "&" }
PIPE                          = _{ "|" }
N                             = _{ NEWLINE }
COMMENT                       = _{ "//" ~ (!"\n" ~ ANY)*}
WHITESPACE                    = _{ " " | "\t" }
